<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP & MCP-B — Demo & Docs</title>
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.4.0/dist/reveal.css">
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.4.0/dist/theme/white.css" id="theme">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title slide (KEEP) -->
            <section>
                <h1>MCP &amp; MCP-B</h1>
                <p>A concise guide and practical walkthrough</p>
                <p><em>Presentation by Stoica Tedy &amp; Frunza Dan</em></p>
                <p>e^iπ = -1</p>
            </section>

            <!-- What is MCP -->
            <section>
                <h2>What is MCP?</h2>
                <p>Model Context Protocol (MCP) is an open standard that connects AI hosts (clients) to context providers (servers).</p>
                <ul>
                    <li>Expose tools, resources and prompts to AI applications.</li>
                    <li>Enables assistants to access data and perform actions securely.</li>
                    <li>Think of MCP as a standardized "port" for AI apps to reach external capabilities.</li>
                </ul>
            </section>

            <section>
                <h2>MCP Diagram</h2>
                <p><img src="assets/mcp-simple-diagram.avif" alt="Simple MCP diagram" style="max-width:100%;height:auto"></p>
            </section>

            <!-- Why does MCP matter -->
            <section>
                <h2>Why MCP matters</h2>
                <ul>
                    <li>Reduces integration complexity for AI apps and tools.</li>
                    <li>Enables rich, real-time, permissioned interactions (e.g., calendar, files).</li>
                    <li>Supports local and remote servers (desktop, cloud, browser).</li>
                </ul>
            </section>

            <!-- Architecture overview -->
            <section>
                <h2>Architecture (high level)</h2>
                <p>MCP splits concerns into two layers:</p>
                <ul>
                    <li><strong>Data layer</strong> — JSON-RPC based primitives, lifecycle, discovery, execution.</li>
                    <li><strong>Transport layer</strong> — connection/authorization (stdio, streamable HTTP, tab transports).</li>
                </ul>
            </section>

            <!-- Diagram -->
            <section>
                <h2>Architecture Diagram</h2>
                <p><img src="assets/architecture-diagram.png" alt="MCP architecture diagram" style="max-width:100%;height:auto"></p>
            </section>

            <!-- Data layer (detailed) -->
            <section>
                <h2>Data Layer</h2>
                <p>The Data layer defines the protocol primitives and JSON-RPC surface:</p>
                <ul>
                    <li><strong>Lifecycle</strong>: initialize / shutdown and capability negotiation.</li>
                    <li><strong>Discovery</strong>: list methods for tools/resources/prompts and schema-driven metadata.</li>
                    <li><strong>Execution</strong>: call/read/task APIs that return structured content and typed outputs.</li>
                    <li><strong>Schema-first</strong>: inputs/outputs should be expressed as JSON Schema for validation and safe execution.</li>
                </ul>
            </section>

            <!-- Participants -->
            <section>
                <h2>Key participants</h2>
                <ul>
                    <li><strong>MCP Host</strong>: AI application (e.g., Claude, VS Code) that coordinates clients.</li>
                    <li><strong>MCP Client</strong>: component inside the host that talks to servers.</li>
                    <li><strong>MCP Server</strong>: provides tools, resources, and prompts.</li>
                </ul>
            </section>

            <!-- Core primitives -->
            <!-- Server Primitives -->
            <section>
                <h2>Server Primitives</h2>
                <p>Server-facing primitives exposed over the Data layer (concise):</p>
                <ul>
                    <li><strong>Tools</strong>: executable functions. Provide <code>name</code>, <code>description</code>, <code>inputSchema</code>, <code>outputSchema</code> and a <code>handler</code>. Handlers return typed structured outputs and a <code>content</code> array for host rendering.</li>
                    <li><strong>Resources</strong>: addressable context (id, mediaType) with <code>read()</code> semantics; support streaming, ranges and metadata for efficient transfer.</li>
                    <li><strong>Prompts</strong>: reusable templates with slots and recommended sampling/hyperparameters</li>
                </ul>
                <!-- example removed here and added in following slide -->
            </section>

            <!-- Server primitive example: Tool -->
            <section>
                <h2>Server primitive — Tool</h2>
                <p><strong>searchFlights</strong> — inputSchema and response:</p>
                <pre><code>{
    "inputSchema": {
        "type": "object",
        "properties": {
            "origin": { "type": "string" },
            "destination": { "type": "string" },
            "date": { "type": "string", "format": "date" }
        },
        "required": ["origin", "destination", "date"]
    },
    "response": {
        "flights": [{ "id": "str", "price": "number", "depart": "string", "arrive": "string", "airline": "string" }],
        "total": "number"
    }
}</code></pre>
            </section>

            <!-- Server primitive example: Resource -->
            <section>
                <h2>Server primitive — Resource</h2>
                <p><strong>calendar://events/2024</strong> — example descriptor:</p>
                <pre><code>{
  "uri": "calendar://events/2024",
  "mimeType": "application/json",
  "description": "User calendar events for 2024",
  "supports": ["read","subscribe"]
}</code></pre>
            </section>

            <!-- Server primitive example: Prompt -->
            <section>
                <h2>Server primitive — Prompt</h2>
                <p><strong>plan-vacation</strong> — example prompt descriptor:</p>
                <pre><code>{
    "name": "plan-vacation",
    "title": "Plan a vacation",
    "description": "Guides a user through planning a vacation",
    "arguments": [
        { "name": "destination", "type": "string", "required": true },
        { "name": "duration", "type": "number" },
        { "name": "budget", "type": "number" }
    ]
}</code></pre>
                <p>Prompts run structured workflows: user chooses prompt, supplies arguments, client orchestrates tools/resources.</p>
            </section>

            <!-- Client primitives (moved) -->
            <section>
                <h2>Client primitives</h2>
                <ul>
                    <li><strong>Sampling</strong>: clients may supply generation settings (temperature, top_p, n) when invoking prompts/tools to control model behavior.</li>
                    <li><strong>Elicitation</strong>: clients orchestrate multi-turn prompting, few-shot contexts, and instrument prompts (examples, anchors) to improve reliability.</li>
                    <li><strong>Logging</strong>: clients should record requests, approvals/denials, decisions and structured outputs for audit, debugging and replay.</li>
                </ul>
            </section>

            <!-- Client examples: Elicitation -->
            <section>
                <h2>Client example — Elicitation</h2>
                <p>Server requests input from user (example):</p>
                <pre><code>{
    "jsonrpc": "2.0",
    "method": "elicitation/requestInput",
    "params": {
        "message": "Please confirm your Barcelona vacation booking details:",
        "schema": {
            "type": "object",
            "properties": {
                "confirmBooking": { "type": "boolean", "description": "Confirm the booking (Flights + Hotel = $3,000)" },
                "seatPreference": { "type": "string", "enum": ["window","aisle","no preference"] }
            },
            "required": ["confirmBooking"]
        }
    }
}</code></pre>
            </section>

            <section>
                <h2>Elicitation example</h2>
                <p><img src="assets/elicitation-flow.png" alt="Elicitation example" style="max-width:100%;height:auto"></p>
            </section>

            <!-- Client examples: Sampling -->
            <section>
                <h2>Client example — Sampling</h2>
                <p>Server asks client to perform an LLM completion on its behalf:</p>
                <pre><code>{
    "jsonrpc": "2.0",
    "method": "sampling/complete",
    "params": {
        "messages": [ { "role": "user", "content": "Analyze these flight options and recommend the best choice:\n[47 flights]" } ],
        "modelPreferences": { "hints":[{"name":"claude-sonnet-4-20250514"}], "costPriority":0.3, "speedPriority":0.2, "intelligencePriority":0.9 },
        "maxTokens": 1500
    }
}</code></pre>
            </section>

            <section>
                <h2>Sampling example</h2>
                <p><img src="assets/sampling-flow.png" alt="Sampling example" style="max-width:100%;height:auto"></p>
            </section>

            <!-- Client examples: Logging -->
            <section>
                <h2>Client example — Logging</h2>
                <p>Server emits logs to the client for debugging/monitoring:</p>
                <pre><code>{
    "jsonrpc": "2.0",
    "method": "logging/log",
    "params": {
        "level": "info",
        "message": "Tool executed: searchFlights",
        "meta": { "tool": "searchFlights", "requestId": "abc123" }
    }
}</code></pre>
            </section>

            <!-- Lifecycle & discovery -->
            <section>
                <h2>Lifecycle &amp; discovery</h2>
                <p>Initialization negotiates protocol version and capabilities; discovery uses list methods (tools/list, resources/list).</p>
                <p>Notifications (e.g., tools/list_changed) enable real-time updates.</p>
            </section>

            <!-- Notifications -->
            <section>
                <h2>Notifications</h2>
                <p>Notifications provide real-time updates from servers to clients/hosts:</p>
                <ul>
                    <li>Common events: <code>tools/list_changed</code>, <code>resources/changed</code>, <code>tasks/updated</code>, <code>prompts/updated</code>.</li>
                    <li>Transports may deliver notifications via SSE, message frames, or in-process callbacks.</li>
                    <li>Notifications should include stable IDs and minimal payloads to enable efficient reconciliation.</li>
                </ul>
            </section>

            <!-- Transport layer (detailed) -->
            <section>
                <h2>Transport Layers</h2>
                <p>Transports carry JSON-RPC messages; choose based on locality, auth and streaming needs:</p>
                <ul>
                    <li><strong>Stdio</strong> — local IPC, low-latency; avoid writing RPC to stdout and use stderr/files for logs.</li>
                    <li><strong>Streamable HTTP</strong> — use bearer/OAuth for auth; support SSE or chunked streaming for long-running responses.</li </ul>
            </section>

            <!-- Tool execution example -->
            <section>
                <h2>Tool execution flow (example)</h2>
                <ol>
                    <li>Client calls <code>tools/call</code> with tool name and arguments.</li>
                    <li>Server validates against tool input schema and executes.</li>
                    <li>Server returns <code>content</code> array + structured output for the host.</li>
                </ol>
            </section>

            <!-- Tool execution example: code -->
            <!-- Tasks feature -->
            <section>
                <h3>Tool execution — example (JSON-RPC)</h3>
                <pre><code>// 1) initialize (client -> server)
POST /initialize
Content-Type: application/json

{
    "jsonrpc": "2.0",
    "method": "initialize",
    "params": { "client": "my-host", "capabilities": {} },
    "id": 1
}

// 2) discover tools
POST /request
Content-Type: application/json

{
    "jsonrpc":"2.0",
    "method":"tools/list",
    "params": {},
    "id": 2
}

// 3) call a tool
POST /request
Content-Type: application/json

{
    "jsonrpc":"2.0",
    "method":"tools/call",
    "params": { "name": "searchFlights", "args": [], "kwargs": { "origin": "NYC", "destination": "BCN", "date":"2025-06-15" } },
    "id": 3
}
                                </code></pre>
            </section>

            <section>
                <h2>Tasks (new feature)</h2>
                <p>Long-running or asynchronous work is modeled as tasks:</p>
                <ul>
                    <li>Create/claim/workflow endpoints: `tasks/create`, `tasks/status`, `tasks/cancel`.</li>
                    <li>Support status updates, progress, result delivery (polling or streamed notifications).</li>
                    <li>Tasks enable durable work across restarts and multi-step operations with retry semantics.</li>
                </ul>
            </section>

            <!-- Building servers -->
            <section>
                <h2>Build an MCP server</h2>
                <ul>
                    <li>Define tools/resources/prompts and JSON Schemas for inputs/outputs.</li>
                    <li>Choose transport (stdio for local, HTTP for remote, Tab for browser).</li>
                    <li>Expose lifecycle handlers and implement tools with clear error handling &amp; logging.</li>
                </ul>
                <p>Tip: use the FastMCP SDK to auto-generate tool definitions from type hints.</p>
            </section>

            <!-- Build an MCP server: code example -->
            <section>
                <h3>Build an MCP server — example (Python)</h3>
                <pre><code>from fastmcp import FastMCP

mcp = FastMCP(name="demo-server")

@mcp.tool(name="add")
def add(a: int, b: int) -> int:
    """Add two integers"""
    return a + b

@mcp.tool(name="get_wade")
def get_wade() -> str:
    # simple demo: fetch and return page HTML (sync for brevity)
    import requests
    r = requests.get("https://example.com/wade")
    return r.text

if __name__ == '__main__':
    # choose transport: stdio for local, or streamable-http for remote
    mcp.run(transport='stdio')
                </code></pre>
            </section>

            <!-- Building clients -->
            <section>
                <h2>Build an MCP client</h2>
                <ul>
                    <li>Create a ClientSession over the chosen transport and call <code>initialize</code>.</li>
                    <li>Use <code>tools/list</code> to discover capabilities and register them with the host.</li>
                    <li>Route tool calls from the LLM through the client to the appropriate server.</li>
                </ul>
            </section>

            <!-- Build an MCP client: code example -->
            <section>
                <h3>Build an MCP client — example (Python)</h3>
                <pre><code>from mcp.client import ClientSession

sess = ClientSession(transport='stdio')
sess.initialize(client_name='demo-host')

# discover tools
tools = sess.call('tools/list')
print('Available tools:', tools)

# call a tool
resp = sess.call('tools/call', { 'name': 'add', 'kwargs': { 'a': 2, 'b': 3 } })
print('Result:', resp)
                </code></pre>
            </section>

            <!-- Connect to local servers -->
            <section>
                <h2>Connect to local MCP servers</h2>
                <p>Common flow (e.g., Claude Desktop): configure a local server in client settings so it launches and attaches via stdio.</p>
                <p>Ensure safe defaults: restrict directories, review approvals, and avoid stdout logs for stdio servers.</p>
            </section>

            <!-- Connect to remote servers -->
            <section>
                <h2>Connect to remote MCP servers</h2>
                <ul>
                    <li>Use streamable HTTP transport and standard auth (bearer tokens, OAuth).</li>
                    <li>Enable server-sent events (SSE) for streaming responses where needed.</li>
                </ul>
            </section>

            <!-- Security -->
            <section>
                <h2>Security &amp; permissions</h2>
                <ul>
                    <li>Authenticate transports (OAuth or tokens) for remote servers.</li>
                    <li>Require explicit user approval for sensitive actions (file access, send email).</li>
                </ul>
                <p>Example: curl with bearer token for a protected streamable HTTP MCP server:</p>
                <pre><code>curl -X POST https://mcp.example.com/request \
  -H 'Authorization: Bearer $MCP_TOKEN' \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"sensitiveOp","kwargs":{}},"id":42}'</code></pre>
            </section>

            <!-- WebMCP / MCP-B intro -->
            <section>
                <h2>WebMCP / MCP‑B (browser-native)</h2>
                <p>WebMCP exposes website functions via <code>navigator.modelContext</code>; MCP‑B provides the browser reference implementation and extension.</p>
                <ul>
                    <li>Zero-backend option: run in-page, tools inherit the user's session &amp; permissions.</li>
                    <li>Useful for in-page automation (add-to-cart, form helpers) with human-in-the-loop control.</li>
                </ul>
            </section>

            <!-- How WebMCP works -->
            <section>
                <h2>How WebMCP / MCP‑B works</h2>
                <ol>
                    <li>Install <code>@mcp-b/global</code> (polyfill) or use the WebMCP API.</li>
                    <li>Register tools (JS functions) with <code>registerTool()</code>.</li>
                    <li>AI agents discover and call tools via the MCP‑B extension or assistant bridges.</li>
                </ol>
            </section>

            <!-- WebMCP quick example -->
            <section>
                <h2>Quick WebMCP example</h2>
                <pre><code>// in-page WebMCP example
import '@mcp-b/global'
import { z } from 'zod'

registerTool({
    name: 'add_to_cart',
    description: 'Add product to cart using current session',
    inputSchema: z.object({ productId: z.string(), quantity: z.number().min(1).default(1) }),
    async handler(ctx, args) {
        // use fetch with user's cookies/session
        await fetch(`/cart/add`, { method: 'POST', credentials: 'include', body: JSON.stringify(args) })
        return { success: true }
    }
})

// client (assistant) will call via MCP‑B bridge/extension
                                </code></pre>
            </section>

            <!-- Developer tools: Inspector -->
            <section>
                <h2>Developer tools</h2>
                <p>MCP Inspector and SDK tools help debug initialization, list responses and tool execution flows.</p>
            </section>

            <!-- Demo slide (KEEP) -->
            <section>
                <h2>Demo</h2>
                <p>We have a demo that shows a running MCP server and a client interaction.</p>
                <pre><code>python3 presentation/mcp_server.py
# then call (example):
curl -s -X POST http://localhost:8765/invoke \
    -H 'Content-Type: application/json' \
    -d '{"function":"get_wade","args":[]}'
                                </code></pre>
            </section>
        </div>
    </div>

    <script src="https://unpkg.com/reveal.js@4.4.0/dist/reveal.js"></script>
    <script>
        const deck = new Reveal();
        deck.initialize({
            hash: true,
            slideNumber: true,
            width: 1100
        });
    </script>
</body>

</html>