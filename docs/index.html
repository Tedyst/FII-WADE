<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCP & MCP-B — Demo & Docs</title>
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.4.0/dist/reveal.css">
    <link rel="stylesheet" href="https://unpkg.com/reveal.js@4.4.0/dist/theme/white.css" id="theme">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title slide (KEEP) -->
            <section>
                <h1>MCP &amp; MCP-B</h1>
                <p>A concise guide and practical walkthrough</p>
                <p><em>Presentation by Stoica Tedy &amp; Fruna Dan</em></p>
            </section>

            <!-- Agenda -->
            <section>
                <h2>Agenda</h2>
                <ol>
                    <li>What is MCP? Why it matters</li>
                    <li>Architecture &amp; core primitives (tools, resources, prompts)</li>
                    <li>Transports, lifecycle and discovery</li>
                    <li>Building with MCP: servers &amp; clients (quick walkthrough)</li>
                    <li>WebMCP / MCP‑B: browser-native model context</li>
                    <li>Security, best practices, SDKs &amp; developer tools</li>
                    <li>Use cases, demo pointer, next steps</li>
                </ol>
            </section>

            <!-- What is MCP -->
            <section>
                <h2>What is MCP?</h2>
                <p>Model Context Protocol (MCP) is an open standard that connects AI hosts (clients) to context providers (servers).</p>
                <ul>
                    <li>Expose tools, resources and prompts to AI applications.</li>
                    <li>Enables assistants to access data and perform actions securely.</li>
                    <li>Think of MCP as a standardized "port" for AI apps to reach external capabilities.</li>
                </ul>
            </section>

            <!-- Why does MCP matter -->
            <section>
                <h2>Why MCP matters</h2>
                <ul>
                    <li>Reduces integration complexity for AI apps and tools.</li>
                    <li>Enables rich, real-time, permissioned interactions (e.g., calendar, files).</li>
                    <li>Supports local and remote servers (desktop, cloud, browser).</li>
                </ul>
            </section>

            <!-- Architecture overview -->
            <section>
                <h2>Architecture (high level)</h2>
                <p>MCP splits concerns into two layers:</p>
                <ul>
                    <li><strong>Data layer</strong> — JSON-RPC based primitives, lifecycle, discovery, execution.</li>
                    <li><strong>Transport layer</strong> — connection/authorization (stdio, streamable HTTP, tab transports).</li>
                </ul>
            </section>

            <!-- Participants -->
            <section>
                <h2>Key participants</h2>
                <ul>
                    <li><strong>MCP Host</strong>: AI application (e.g., Claude, VS Code) that coordinates clients.</li>
                    <li><strong>MCP Client</strong>: component inside the host that talks to servers.</li>
                    <li><strong>MCP Server</strong>: provides tools, resources, and prompts.</li>
                </ul>
            </section>

            <!-- Core primitives -->
            <section>
                <h2>Core primitives</h2>
                <ul>
                    <li><strong>Tools</strong>: executable functions (discover/list/call).</li>
                    <li><strong>Resources</strong>: addressable context data (list/read).</li>
                    <li><strong>Prompts</strong>: reusable templates for model interactions.</li>
                </ul>
            </section>

            <!-- Lifecycle & discovery -->
            <section>
                <h2>Lifecycle &amp; discovery</h2>
                <p>Initialization negotiates protocol version and capabilities; discovery uses list methods (tools/list, resources/list).</p>
                <p>Notifications (e.g., tools/list_changed) enable real-time updates.</p>
            </section>

            <!-- Transports -->
            <section>
                <h2>Transports</h2>
                <ul>
                    <li><strong>Stdio</strong>: local process IPC (fast, no network).</li>
                    <li><strong>Streamable HTTP</strong>: remote servers with optional SSE streaming.</li>
                    <li><strong>Tab / Browser transports</strong>: used by WebMCP / MCP‑B (in-page/tab servers).</li>
                </ul>
            </section>

                        <!-- Tool execution example -->
                        <section>
                                <h2>Tool execution flow (example)</h2>
                                <ol>
                                        <li>Client calls <code>tools/call</code> with tool name and arguments.</li>
                                        <li>Server validates against tool input schema and executes.</li>
                                        <li>Server returns <code>content</code> array + structured output for the host.</li>
                                </ol>
                        </section>

                        <!-- Tool execution example: code -->
                        <section>
                                <h3>Tool execution — example (JSON-RPC)</h3>
                                <pre><code>// 1) initialize (client -> server)
POST /initialize
Content-Type: application/json

{
    "jsonrpc": "2.0",
    "method": "initialize",
    "params": { "client": "my-host", "capabilities": {} },
    "id": 1
}

// 2) discover tools
POST /request
Content-Type: application/json

{
    "jsonrpc":"2.0",
    "method":"tools/list",
    "params": {},
    "id": 2
}

// 3) call a tool
POST /request
Content-Type: application/json

{
    "jsonrpc":"2.0",
    "method":"tools/call",
    "params": { "name": "searchFlights", "args": [], "kwargs": { "origin": "NYC", "destination": "BCN", "date":"2025-06-15" } },
    "id": 3
}
                                </code></pre>
                        </section>

            <!-- Building servers -->
            <section>
                <h2>Build an MCP server (quick)</h2>
                <ul>
                    <li>Define tools/resources/prompts and JSON Schemas for inputs/outputs.</li>
                    <li>Choose transport (stdio for local, HTTP for remote, Tab for browser).</li>
                    <li>Expose lifecycle handlers and implement tools with clear error handling &amp; logging.</li>
                </ul>
                <p>Tip: use the FastMCP SDK to auto-generate tool definitions from type hints.</p>
            </section>

            <!-- Build an MCP server: code example -->
            <section>
                <h3>Build an MCP server — example (Python)</h3>
                <pre><code>from fastmcp import FastMCP

mcp = FastMCP(name="demo-server")

@mcp.tool(name="add")
def add(a: int, b: int) -> int:
    """Add two integers"""
    return a + b

@mcp.tool(name="get_wade")
def get_wade() -> str:
    # simple demo: fetch and return page HTML (sync for brevity)
    import requests
    r = requests.get("https://example.com/wade")
    return r.text

if __name__ == '__main__':
    # choose transport: stdio for local, or streamable-http for remote
    mcp.run(transport='stdio')
                </code></pre>
            </section>

            <!-- Building clients -->
            <section>
                <h2>Build an MCP client (quick)</h2>
                <ul>
                    <li>Create a ClientSession over the chosen transport and call <code>initialize</code>.</li>
                    <li>Use <code>tools/list</code> to discover capabilities and register them with the host.</li>
                    <li>Route tool calls from the LLM through the client to the appropriate server.</li>
                </ul>
            </section>

            <!-- Build an MCP client: code example -->
            <section>
                <h3>Build an MCP client — example (Python)</h3>
                <pre><code>from mcp.client import ClientSession

sess = ClientSession(transport='stdio')
sess.initialize(client_name='demo-host')

# discover tools
tools = sess.call('tools/list')
print('Available tools:', tools)

# call a tool
resp = sess.call('tools/call', { 'name': 'add', 'kwargs': { 'a': 2, 'b': 3 } })
print('Result:', resp)
                </code></pre>
            </section>

            <!-- Connect to local servers -->
            <section>
                <h2>Connect to local MCP servers</h2>
                <p>Common flow (e.g., Claude Desktop): configure a local server in client settings so it launches and attaches via stdio.</p>
                <p>Ensure safe defaults: restrict directories, review approvals, and avoid stdout logs for stdio servers.</p>
            </section>

            <!-- Connect to remote servers -->
            <section>
                <h2>Connect to remote MCP servers</h2>
                <ul>
                    <li>Use streamable HTTP transport and standard auth (bearer tokens, OAuth).</li>
                    <li>Enable server-sent events (SSE) for streaming responses where needed.</li>
                </ul>
            </section>

            <!-- SDKs & examples -->
            <section>
                <h2>SDKs &amp; examples</h2>
                <p>Official SDKs simplify lifecycle, transport handling, and primitive helpers (Python, TypeScript, Go).</p>
                <p>Include short examples and quickstart repos for integrators (link in notes).</p>
                <p>TypeScript (server) example using streamable HTTP:</p>
                <pre><code>import { McpServer } from '@modelcontextprotocol/sdk/server'
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp'

const server = new McpServer({ name: 'demo-ts', version: '0.1.0' })

server.registerTool('add', { description: 'Add two numbers' }, async ({ a, b }) =&gt; ({ structuredContent: { sum: a + b }, content: [{ type: 'text', text: `sum=${a+b}` }] }))

// wire into express/HTTP
// see SDK docs for full example
                </code></pre>
            </section>

            <!-- Security -->
            <section>
                <h2>Security &amp; permissions</h2>
                <ul>
                    <li>Authenticate transports (OAuth or tokens) for remote servers.</li>
                    <li>Require explicit user approval for sensitive actions (file access, send email).</li>
                    <li>Log to stderr or files for stdio servers; never write JSON-RPC to stdout.</li>
                </ul>
                <p>Example: curl with bearer token for a protected streamable HTTP MCP server:</p>
                <pre><code>curl -X POST https://mcp.example.com/request \
  -H 'Authorization: Bearer $MCP_TOKEN' \
  -H 'Content-Type: application/json' \
  -d '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"sensitiveOp","kwargs":{}},"id":42}'
                </code></pre>
            </section>

            <!-- Developer tools: Inspector -->
            <section>
                <h2>Developer tools</h2>
                <p>MCP Inspector and SDK tools help debug initialization, list responses and tool execution flows.</p>
            </section>

            <!-- WebMCP / MCP-B intro -->
            <section>
                <h2>WebMCP / MCP‑B (browser-native)</h2>
                <p>WebMCP exposes website functions via <code>navigator.modelContext</code>; MCP‑B provides the browser reference implementation and extension.</p>
                <ul>
                    <li>Zero-backend option: run in-page, tools inherit the user's session &amp; permissions.</li>
                    <li>Useful for in-page automation (add-to-cart, form helpers) with human-in-the-loop control.</li>
                </ul>
            </section>

            <!-- How WebMCP works -->
            <section>
                <h2>How WebMCP / MCP‑B works</h2>
                <ol>
                    <li>Install <code>@mcp-b/global</code> (polyfill) or use the WebMCP API.</li>
                    <li>Register tools (JS functions) with <code>registerTool()</code>.</li>
                    <li>AI agents discover and call tools via the MCP‑B extension or assistant bridges.</li>
                </ol>
            </section>

            <!-- WebMCP quick example -->
            <section>
                <h2>Quick WebMCP example</h2>
                                <pre><code>// in-page WebMCP example
import '@mcp-b/global'
import { z } from 'zod'

registerTool({
    name: 'add_to_cart',
    description: 'Add product to cart using current session',
    inputSchema: z.object({ productId: z.string(), quantity: z.number().min(1).default(1) }),
    async handler(ctx, args) {
        // use fetch with user's cookies/session
        await fetch(`/cart/add`, { method: 'POST', credentials: 'include', body: JSON.stringify(args) })
        return { success: true }
    }
})

// client (assistant) will call via MCP‑B bridge/extension
                                </code></pre>
            </section>

            <!-- Best practices summary -->
            <section>
                <h2>Best practices (summary)</h2>
                <ul>
                    <li>Provide JSON Schemas for tools and validate server-side.</li>
                    <li>Version tools and use semantic versioning for breaking changes.</li>
                    <li>Return structured content + short human text for clarity.</li>
                    <li>Minimize surface area for sensitive actions; require user approval.</li>
                    <li>Keep examples and a README for integrators.</li>
                </ul>
            </section>

            <!-- Use cases -->
            <section>
                <h2>Use cases &amp; scenarios</h2>
                <ul>
                    <li>Personal assistants: calendar, email, file management (with approval).</li>
                    <li>Commerce: add-to-cart, checkout helpers via WebMCP.</li>
                    <li>Automation: media processing, batch tasks, streaming large artifacts.</li>
                </ul>
            </section>

            <!-- Demo slide (KEEP) -->
                        <section>
                                <h2>Demo</h2>
                                <p>We have a demo that shows a running MCP server and a client interaction.</p>
                                <pre><code>python3 presentation/mcp_server.py
# then call (example):
curl -s -X POST http://localhost:8765/invoke \
    -H 'Content-Type: application/json' \
    -d '{"function":"get_wade","args":[]}'
                                </code></pre>
                        </section>

            <!-- Closing & next steps -->
            <section>
                <h2>Next steps &amp; resources</h2>
                <ul>
                    <li>Read the MCP spec and SDK docs (modelcontextprotocol.io/docs)</li>
                    <li>Try WebMCP quickstart and the MCP‑B extension (docs.mcp-b.ai)</li>
                    <li>Implement a small server and client (weather quickstart example)</li>
                </ul>
                <p>Questions?</p>
            </section>
        </div>
    </div>

    <script src="https://unpkg.com/reveal.js@4.4.0/dist/reveal.js"></script>
    <script>
        const deck = new Reveal();
        deck.initialize({
            hash: true,
            slideNumber: true,
            width: 1100
        });
    </script>
</body>

</html>